<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Swim Coach App</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        import React, { useState, useEffect } from 'react';
import { Clock, Plus, Trash2, Users, Settings, X, Upload, Download, RefreshCw, Play, Square, ExternalLink } from 'lucide-react';

const GROUP_COLORS = [
  { bg: 'bg-blue-100', active: 'bg-blue-500' },
  { bg: 'bg-green-100', active: 'bg-green-500' },
  { bg: 'bg-purple-100', active: 'bg-purple-500' },
  { bg: 'bg-orange-100', active: 'bg-orange-500' },
  { bg: 'bg-pink-100', active: 'bg-pink-500' }
];

const EVENTS = [
  '50 Free', '100 Free', '200 Free', '500 Free', '1000 Free', '1650 Free',
  '50 Back', '100 Back', '200 Back',
  '50 Breast', '100 Breast', '200 Breast',
  '50 Fly', '100 Fly', '200 Fly',
  '200 IM', '400 IM'
];

export default function SwimCoachApp() {
  const [numLanes, setNumLanes] = useState(3);
  const [athletes, setAthletes] = useState([]);
  const [lanes, setLanes] = useState({});
  const [showRoster, setShowRoster] = useState(false);
  const [editingAthlete, setEditingAthlete] = useState(null);
  const [showLaneConfig, setShowLaneConfig] = useState(false);
  const [draggedAthlete, setDraggedAthlete] = useState(null);
  const [showManualImport, setShowManualImport] = useState(false);
  const [manualImportText, setManualImportText] = useState('');
  const [showSaveSetModal, setShowSaveSetModal] = useState(false);
  const [showBestTimeModal, setShowBestTimeModal] = useState(null);
  const [showBatchImport, setShowBatchImport] = useState({});
  const [batchImportText, setBatchImportText] = useState({});
  const [showAllTimes, setShowAllTimes] = useState(null);
  const [courseView, setCourseView] = useState('SCY');
  
  const [repeats, setRepeats] = useState(3);
  const [distance, setDistance] = useState(100);
  const [cycleTime, setCycleTime] = useState(30);
  const [sendoff, setSendoff] = useState(5);
  const [laneSettings, setLaneSettings] = useState({});
  const [editingLane, setEditingLane] = useState(null);
  const [setRunning, setSetRunning] = useState(false);
  const [, setTick] = useState(0);
  
  const [swimmerStates, setSwimmerStates] = useState({});

  useEffect(() => {
    if (!setRunning) return;
    
    const interval = setInterval(() => {
      const now = Date.now();
      setTick(t => t + 1);
      
      setSwimmerStates(prev => {
        const updated = { ...prev };
        let changed = false;
        
        Object.keys(updated).forEach(id => {
          const state = updated[id];
          if (!state.repStartTime) return;
          if (now < state.repStartTime) return;
          
          const elapsed = (now - state.repStartTime) / 1000;
          const laneCycle = state.laneCycleTime || cycleTime;
          
          if (elapsed >= laneCycle) {
            const laneRepeats = state.laneRepeats || repeats;
            if (state.repNum < laneRepeats) {
              updated[id] = {
                ...state,
                repNum: state.repNum + 1,
                repStartTime: now,
                hasSplit: false
              };
              changed = true;
            } else {
              updated[id] = { ...state, repStartTime: null };
              changed = true;
            }
          }
        });
        
        return changed ? updated : prev;
      });
    }, 50);
    
    return () => clearInterval(interval);
  }, [setRunning, cycleTime, repeats]);

  const startSet = () => {
    const now = Date.now();
    const states = {};
    
    Object.keys(lanes).forEach(laneNum => {
      const laneConfig = laneSettings[laneNum] || {};
      const laneRepeats = laneConfig.repeats || repeats;
      const laneCycle = laneConfig.cycleTime || cycleTime;
      const laneSendoff = laneConfig.sendoff || sendoff;
      
      lanes[laneNum].forEach((athleteId, index) => {
        states[athleteId] = {
          repNum: 1,
          repStartTime: now + (index * laneSendoff * 1000),
          hasSplit: false,
          splits: [],
          groupIndex: index,
          laneRepeats: laneRepeats,
          laneCycleTime: laneCycle
        };
      });
    });
    
    setSwimmerStates(states);
    setSetRunning(true);
  };

  const stopSet = () => {
    setSetRunning(false);
    setShowSaveSetModal(true);
  };

  const saveSetData = () => {
    const newBestTimes = [];
    if (distance === 100) {
      Object.keys(swimmerStates).forEach(athleteId => {
        const athlete = athletes.find(a => a.id === athleteId);
        if (!athlete) return;
        
        const state = swimmerStates[athleteId];
        if (!state.splits || state.splits.length === 0) return;
        
        const fastestSplit = Math.min(...state.splits.map(s => s.time));
        
        const currentBest = athlete.times?.['100 Free']?.['SCY'];
        const currentBestSeconds = currentBest ? timeToSeconds(currentBest) : 999999;
        
        if (fastestSplit < currentBestSeconds) {
          newBestTimes.push({
            athleteId,
            athleteName: athlete.name,
            oldTime: currentBest || null,
            newTime: fastestSplit
          });
        }
      });
    }
    
    setShowSaveSetModal(false);
    
    if (newBestTimes.length > 0) {
      setShowBestTimeModal(newBestTimes);
    } else {
      resetSet();
    }
  };

  const discardSetData = () => {
    setShowSaveSetModal(false);
    resetSet();
  };

  const approveBestTime = (athleteId, newTime) => {
    const timeStr = formatSecondsToTime(newTime);
    setAthletes(prev => prev.map(athlete => {
      if (athlete.id === athleteId) {
        const newTimes = { ...(athlete.times || {}) };
        if (!newTimes['100 Free']) newTimes['100 Free'] = {};
        newTimes['100 Free']['SCY'] = timeStr;
        return { ...athlete, times: newTimes };
      }
      return athlete;
    }));
  };

  const resetSet = () => {
    setSwimmerStates({});
    setShowBestTimeModal(null);
  };

  const recordSplit = (athleteId) => {
    if (!setRunning) return;
    
    setSwimmerStates(prev => {
      const state = prev[athleteId];
      if (!state || state.hasSplit || !state.repStartTime) return prev;
      
      const now = Date.now();
      if (now < state.repStartTime) return prev;
      
      const splitTime = (now - state.repStartTime) / 1000;
      
      if (window.navigator?.vibrate) {
        window.navigator.vibrate(50);
      }
      
      return {
        ...prev,
        [athleteId]: {
          ...state,
          hasSplit: true,
          splits: [...state.splits, { rep: state.repNum, time: splitTime }]
        }
      };
    });
  };

  const getLaneConfig = (laneNum) => {
    return laneSettings[laneNum] || { repeats, cycleTime, sendoff };
  };

  const updateLaneSettings = (laneNum, settings) => {
    setLaneSettings(prev => ({
      ...prev,
      [laneNum]: { ...getLaneConfig(laneNum), ...settings }
    }));
  };

  const resetLaneSettings = (laneNum) => {
    setLaneSettings(prev => {
      const newSettings = { ...prev };
      delete newSettings[laneNum];
      return newSettings;
    });
  };

  const moveAthleteInLane = (laneNum, athleteId, direction) => {
    const laneAthletes = lanes[laneNum] || [];
    const currentIndex = laneAthletes.indexOf(athleteId);
    
    if (currentIndex === -1) return;
    if (direction === 'up' && currentIndex === 0) return;
    if (direction === 'down' && currentIndex === laneAthletes.length - 1) return;
    
    const newIndex = direction === 'up' ? currentIndex - 1 : currentIndex + 1;
    const newLaneAthletes = [...laneAthletes];
    
    // Swap positions
    [newLaneAthletes[currentIndex], newLaneAthletes[newIndex]] = 
    [newLaneAthletes[newIndex], newLaneAthletes[currentIndex]];
    
    // Update lanes
    setLanes(prev => ({
      ...prev,
      [laneNum]: newLaneAthletes
    }));
    
    // If set is running, adjust timers
    if (setRunning) {
      const now = Date.now();
      const laneConfig = laneSettings[laneNum] || {};
      const laneSendoff = (laneConfig.sendoff || sendoff) * 1000;
      const swappedAthleteId = newLaneAthletes[currentIndex];
      
      setSwimmerStates(prev => {
        const updated = { ...prev };
        const athlete1State = updated[athleteId];
        const athlete2State = updated[swappedAthleteId];
        
        if (athlete1State && athlete2State) {
          const timeDiff = laneSendoff * (direction === 'up' ? -1 : 1);
          
          // Adjust start times for both athletes
          if (athlete1State.repStartTime) {
            athlete1State.repStartTime += timeDiff;
          }
          if (athlete2State.repStartTime) {
            athlete2State.repStartTime -= timeDiff;
          }
          
          // Update group indices
          athlete1State.groupIndex = newIndex;
          athlete2State.groupIndex = currentIndex;
        }
        
        return updated;
      });
    }
  };

  const formatSeconds = (seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = (seconds % 60).toFixed(2);
    return mins > 0 ? `${mins}:${secs.padStart(5, '0')}` : secs;
  };

  const formatSecondsToTime = (seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = (seconds % 60).toFixed(2);
    return mins > 0 ? `${mins}:${secs.padStart(5, '0')}` : secs;
  };

  const timeToSeconds = (timeStr) => {
    if (!timeStr) return 999999;
    const parts = timeStr.split(':');
    if (parts.length === 2) {
      return parseFloat(parts[0]) * 60 + parseFloat(parts[1]);
    }
    return parseFloat(timeStr);
  };

  const addAthlete = () => {
    const newAthlete = {
      id: Date.now().toString(),
      name: 'New Athlete',
      swimCloudUrl: '',
      times: {},
      active: true
    };
    setAthletes([newAthlete, ...athletes]);
    setEditingAthlete(newAthlete.id);
  };

  const updateAthlete = (id, field, value) => {
    setAthletes(athletes.map(a => a.id === id ? { ...a, [field]: value } : a));
  };

  const deleteAthlete = (id) => {
    setAthletes(athletes.filter(a => a.id !== id));
    const newLanes = { ...lanes };
    Object.keys(newLanes).forEach(lane => {
      newLanes[lane] = newLanes[lane].filter(aId => aId !== id);
    });
    setLanes(newLanes);
  };

  const distributeAthletes = () => {
    const activeAthletes = athletes.filter(a => a.active !== false);
    const athletesWithTimes = activeAthletes.map(a => ({
      ...a,
      sortTime: getSortTime(a)
    })).sort((a, b) => a.sortTime - b.sortTime);

    const newLanes = {};
    for (let i = 1; i <= numLanes; i++) {
      newLanes[i] = [];
    }
    
    const athletesPerLane = Math.ceil(athletesWithTimes.length / numLanes);
    
    athletesWithTimes.forEach((athlete, index) => {
      const laneNum = Math.floor(index / athletesPerLane) + 1;
      if (laneNum <= numLanes) {
        newLanes[laneNum].push(athlete.id);
      }
    });
    
    setLanes(newLanes);
  };

  const distributeAthletesRoundRobin = () => {
    const activeAthletes = athletes.filter(a => a.active !== false);
    const athletesWithTimes = activeAthletes.map(a => ({
      ...a,
      sortTime: getSortTime(a)
    })).sort((a, b) => a.sortTime - b.sortTime);

    const newLanes = {};
    for (let i = 1; i <= numLanes; i++) {
      newLanes[i] = [];
    }
    
    athletesWithTimes.forEach((athlete, index) => {
      const laneNum = (index % numLanes) + 1;
      newLanes[laneNum].push(athlete.id);
    });
    
    setLanes(newLanes);
  };

  const getSortTime = (athlete) => {
    if (athlete.times?.['100 Free']) {
      const time100 = athlete.times['100 Free']['SCY'] || athlete.times['100 Free']['LCM'] || athlete.times['100 Free']['SCM'];
      if (time100) return timeToSeconds(time100);
    }
    if (athlete.times?.['50 Free']) {
      const time50 = athlete.times['50 Free']['SCY'] || athlete.times['50 Free']['LCM'] || athlete.times['50 Free']['SCM'];
      if (time50) return timeToSeconds(time50) * 2 + 10;
    }
    return 999999;
  };

  const getDisplayTime = (athlete) => {
    if (athlete.times?.['100 Free']) {
      const time100 = athlete.times['100 Free']['SCY'] || athlete.times['100 Free']['LCM'] || athlete.times['100 Free']['SCM'];
      if (time100) return time100;
    }
    return '';
  };

  const processBatchImport = (athleteId) => {
    const text = batchImportText[athleteId] || '';
    const lines = text.split('\n');
    const newTimes = { ...(athletes.find(a => a.id === athleteId)?.times || {}) };

    lines.forEach(line => {
      const courseMatch = line.match(/\b(SCY|LCM|SCM)\b/i);
      const course = courseMatch ? courseMatch[1].toUpperCase() : 'SCY';

      let eventName = null;
      for (const event of EVENTS) {
        const eventPattern = event.replace(/\s+/g, '\\s*');
        const regex = new RegExp(eventPattern, 'i');
        if (regex.test(line)) {
          eventName = event;
          break;
        }
      }

      if (!eventName) return;

      const timeMatch = line.match(/(\d+:)?\d+\.\d+/);
      if (timeMatch) {
        const time = timeMatch[0];
        if (!newTimes[eventName]) newTimes[eventName] = {};
        newTimes[eventName][course] = time;
      }
    });

    updateAthlete(athleteId, 'times', newTimes);
    setBatchImportText(prev => ({ ...prev, [athleteId]: '' }));
    setShowBatchImport(prev => ({ ...prev, [athleteId]: false }));
  };

  const exportData = () => {
    const data = {
      athletes,
      numLanes,
      exportDate: new Date().toISOString()
    };
    const jsonStr = JSON.stringify(data, null, 2);
    
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(jsonStr).then(() => {
        alert('Data copied to clipboard!');
      }).catch(() => {
        prompt('Copy this data:', jsonStr);
      });
    } else {
      prompt('Copy this data:', jsonStr);
    }
  };

  const importFromClipboard = () => {
    setShowManualImport(true);
  };

  const processImportData = (jsonText) => {
    try {
      const data = JSON.parse(jsonText);
      if (data.athletes) {
        setAthletes(data.athletes);
      }
      if (data.numLanes) {
        setNumLanes(data.numLanes);
      }
      setLanes({});
      setShowManualImport(false);
      setManualImportText('');
      alert('Data imported successfully!');
    } catch (err) {
      alert('Error importing data.');
    }
  };

  const handleDragStart = (e, athleteId) => {
    if (setRunning) return;
    setDraggedAthlete(athleteId);
  };

  const handleDragOver = (e) => {
    e.preventDefault();
  };

  const handleDrop = (e, laneNum) => {
    e.preventDefault();
    if (!draggedAthlete || setRunning) return;

    const athlete = athletes.find(a => a.id === draggedAthlete);
    if (!athlete || athlete.active === false) return;

    const newLanes = { ...lanes };
    Object.keys(newLanes).forEach(lane => {
      newLanes[lane] = newLanes[lane].filter(id => id !== draggedAthlete);
    });

    if (!newLanes[laneNum]) newLanes[laneNum] = [];
    newLanes[laneNum].push(draggedAthlete);

    setLanes(newLanes);
    setDraggedAthlete(null);
  };

  const AthleteCard = ({ athlete, laneNum }) => {
    const [touchStart, setTouchStart] = useState(null);
    const state = swimmerStates[athlete.id];
    const laneAthletes = lanes[laneNum] || [];
    const athleteIndex = laneAthletes.indexOf(athlete.id);
    const isFirst = athleteIndex === 0;
    const isLast = athleteIndex === laneAthletes.length - 1;
    const groupIndex = lanes[laneNum]?.indexOf(athlete.id) || 0;
    const groupColor = GROUP_COLORS[groupIndex % GROUP_COLORS.length];
    
    const getCurrentTime = () => {
      if (!state || !state.repStartTime) return 0;
      const now = Date.now();
      if (now < state.repStartTime) return 0;
      const laneCycle = state.laneCycleTime || cycleTime;
      const elapsed = (now - state.repStartTime) / 1000;
      return Math.min(elapsed, laneCycle - 0.01);
    };
    
    const currentTime = setRunning && state ? getCurrentTime() : 0;
    const now = Date.now();
    const isWaiting = setRunning && state && state.repStartTime && now < state.repStartTime;
    const isActive = setRunning && state && state.repStartTime && now >= state.repStartTime;
    const isComplete = setRunning && state && !state.repStartTime;
    const hasSplit = state?.hasSplit || false;
    const lastSplit = state?.splits?.length > 0 ? state.splits[state.splits.length - 1] : null;
    const laneRepeats = state?.laneRepeats || repeats;
    
    const getBestTimeDisplay = () => {
      if (athlete.times?.['100 Free']) {
        const time = athlete.times['100 Free']['SCY'] || athlete.times['100 Free']['LCM'] || athlete.times['100 Free']['SCM'];
        if (time) return { event: '100 Free', time };
      }
      if (athlete.times?.['50 Free']) {
        const time = athlete.times['50 Free']['SCY'] || athlete.times['50 Free']['LCM'] || athlete.times['50 Free']['SCM'];
        if (time) return { event: '50 Free', time };
      }
      return null;
    };

    const bestTime = getBestTimeDisplay();
    
    const handleTouchStart = (e) => {
      if (!isActive) return;
      setTouchStart(Date.now());
    };

    const handleTouchEnd = (e) => {
      if (!isActive || !touchStart) return;
      const touchDuration = Date.now() - touchStart;
      setTouchStart(null);
      
      // Only record split if touch was less than 200ms (quick tap)
      if (touchDuration < 200) {
        recordSplit(athlete.id);
      }
    };

    const handleMouseDown = (e) => {
      if (!isActive) return;
      setTouchStart(Date.now());
    };

    const handleMouseUp = (e) => {
      if (!isActive || !touchStart) return;
      const touchDuration = Date.now() - touchStart;
      setTouchStart(null);
      
      // Only record split if click was less than 200ms (quick click)
      if (touchDuration < 200) {
        recordSplit(athlete.id);
      }
    };
    
    return (
      <div
        draggable={!setRunning}
        onDragStart={(e) => handleDragStart(e, athlete.id)}
        onMouseDown={handleMouseDown}
        onMouseUp={handleMouseUp}
        onTouchStart={handleTouchStart}
        onTouchEnd={handleTouchEnd}
        className={`rounded-lg shadow-md p-2 transition-all border-2 ${
          isComplete ? 'bg-gray-200 border-gray-400' :
          isWaiting ? `${groupColor.bg} border-gray-400` :
          hasSplit ? 'bg-gray-300 border-gray-500' :
          isActive ? `${groupColor.active} border-blue-400 cursor-pointer active:scale-95` :
          'bg-white border-gray-300'
        } touch-manipulation`}
        style={{ minHeight: '80px', userSelect: 'none' }}
      >
        <div className="flex items-start gap-1">
          <div className="flex flex-col gap-0.5 flex-shrink-0">
            {!isFirst && (
              <button
                onClick={(e) => {
                  e.stopPropagation();
                  e.preventDefault();
                }}
                onTouchStart={(e) => {
                  e.stopPropagation();
                }}
                onTouchEnd={(e) => {
                  e.stopPropagation();
                  e.preventDefault();
                  moveAthleteInLane(laneNum, athlete.id, 'up');
                }}
                onMouseDown={(e) => {
                  e.stopPropagation();
                }}
                onMouseUp={(e) => {
                  e.stopPropagation();
                  e.preventDefault();
                  moveAthleteInLane(laneNum, athlete.id, 'up');
                }}
                className={`p-0.5 rounded ${
                  isActive ? 'bg-white/20 hover:bg-white/30' : 'bg-gray-200 hover:bg-gray-300'
                }`}
              >
                <svg width="12" height="12" viewBox="0 0 12 12" fill="none" className={isActive ? 'text-white' : 'text-gray-600'}>
                  <path d="M6 3L9 7H3L6 3Z" fill="currentColor"/>
                </svg>
              </button>
            )}
            {!isLast && (
              <button
                onClick={(e) => {
                  e.stopPropagation();
                  e.preventDefault();
                }}
                onTouchStart={(e) => {
                  e.stopPropagation();
                }}
                onTouchEnd={(e) => {
                  e.stopPropagation();
                  e.preventDefault();
                  moveAthleteInLane(laneNum, athlete.id, 'down');
                }}
                onMouseDown={(e) => {
                  e.stopPropagation();
                }}
                onMouseUp={(e) => {
                  e.stopPropagation();
                  e.preventDefault();
                  moveAthleteInLane(laneNum, athlete.id, 'down');
                }}
                className={`p-0.5 rounded ${
                  isActive ? 'bg-white/20 hover:bg-white/30' : 'bg-gray-200 hover:bg-gray-300'
                }`}
              >
                <svg width="12" height="12" viewBox="0 0 12 12" fill="none" className={isActive ? 'text-white' : 'text-gray-600'}>
                  <path d="M6 9L3 5H9L6 9Z" fill="currentColor"/>
                </svg>
              </button>
            )}
          </div>
          <div className="flex-1 min-w-0">
            <div className={`font-semibold text-xs truncate ${
              hasSplit ? 'text-gray-700' :
              isActive ? 'text-white' : 
              'text-gray-800'
            }`}>
              {athlete.name}
            </div>
          </div>
        </div>
        
        {setRunning && state && (
          <div className="mt-1">
            <div className="text-xs text-gray-500">
              {state.repNum}/{laneRepeats}
            </div>
            <div className={`text-xl font-mono font-bold leading-tight ${
              isWaiting ? 'text-blue-600' : 
              hasSplit ? 'text-red-600' :
              isActive ? 'text-green-400' :
              'text-gray-400'
            }`}>
              {isWaiting ? 'Wait' : isComplete ? 'Done' : formatSeconds(currentTime)}
            </div>
            {lastSplit && (
              <div className={`text-xs mt-0.5 font-mono ${
                hasSplit ? 'text-gray-600' :
                isActive ? 'text-white' : 
                'text-gray-600'
              }`}>
                {lastSplit.rep}. {formatSeconds(lastSplit.time)}
              </div>
            )}
          </div>
        )}

        {!setRunning && bestTime && (
          <div className="mt-1">
            <div className="text-xs text-gray-500">{bestTime.event}</div>
            <div className="text-sm font-mono font-bold text-blue-600">{bestTime.time}</div>
            <button
              onClick={(e) => {
                e.stopPropagation();
                setShowAllTimes(athlete.id);
              }}
              className="mt-1 text-xs text-purple-600 hover:text-purple-800 underline"
            >
              View all times
            </button>
          </div>
        )}

        {!setRunning && !bestTime && (
          <div className="mt-1">
            <div className="text-xs text-gray-400">No times yet</div>
            <button
              onClick={(e) => {
                e.stopPropagation();
                setShowAllTimes(athlete.id);
              }}
              className="mt-1 text-xs text-purple-600 hover:text-purple-800 underline"
            >
              View all times
            </button>
          </div>
        )}
      </div>
    );
  };

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-cyan-50">
      <div className="sticky top-0 z-40 bg-white shadow-md p-3">
        <div className="flex items-center justify-between mb-2">
          <h1 className="text-xl font-bold text-gray-800 flex items-center gap-2">
            <Clock className="text-blue-600" size={24} />
            Swim Coach
          </h1>
          <div className="flex items-center gap-2">
            {!setRunning ? (
              <button
                onClick={startSet}
                disabled={Object.keys(lanes).length === 0}
                className="px-4 py-2 bg-green-600 text-white rounded-lg font-medium disabled:bg-gray-400"
              >
                <Play size={18} className="inline mr-1" />
                Start
              </button>
            ) : (
              <button
                onClick={stopSet}
                className="px-4 py-2 bg-red-600 text-white rounded-lg font-medium"
              >
                <Square size={18} className="inline mr-1" />
                Stop
              </button>
            )}
            {!setRunning && (
              <>
                <button
                  onClick={() => setShowLaneConfig(!showLaneConfig)}
                  className="p-2 bg-teal-600 text-white rounded-lg"
                >
                  <Settings size={18} />
                </button>
                <button
                  onClick={() => setShowRoster(!showRoster)}
                  className="p-2 bg-blue-600 text-white rounded-lg"
                >
                  <Users size={18} />
                </button>
              </>
            )}
          </div>
        </div>

        {!setRunning && (
          <div className="mt-2 p-3 bg-gray-50 rounded-lg">
            <div className="grid grid-cols-4 gap-2 mb-2">
              <div>
                <label className="text-xs font-medium">Reps</label>
                <input
                  type="text"
                  inputMode="numeric"
                  value={repeats}
                  onFocus={(e) => e.target.select()}
                  onChange={(e) => {
                    const val = e.target.value;
                    if (val === '') {
                      setRepeats('');
                    } else {
                      const num = parseInt(val);
                      if (!isNaN(num) && num > 0) setRepeats(num);
                    }
                  }}
                  onBlur={(e) => {
                    if (e.target.value === '') setRepeats(3);
                  }}
                  className="w-full px-2 py-1 border rounded text-sm"
                />
              </div>
              <div>
                <label className="text-xs font-medium">Distance</label>
                <input
                  type="text"
                  inputMode="numeric"
                  value={distance}
                  onFocus={(e) => e.target.select()}
                  onChange={(e) => {
                    const val = e.target.value;
                    if (val === '') {
                      setDistance('');
                    } else {
                      const num = parseInt(val);
                      if (!isNaN(num) && num > 0) setDistance(num);
                    }
                  }}
                  onBlur={(e) => {
                    if (e.target.value === '') setDistance(100);
                  }}
                  className="w-full px-2 py-1 border rounded text-sm"
                />
              </div>
              <div>
                <label className="text-xs font-medium">Cycle (s)</label>
                <input
                  type="text"
                  inputMode="numeric"
                  value={cycleTime}
                  onFocus={(e) => e.target.select()}
                  onChange={(e) => {
                    const val = e.target.value;
                    if (val === '') {
                      setCycleTime('');
                    } else {
                      const num = parseInt(val);
                      if (!isNaN(num) && num > 0) setCycleTime(num);
                    }
                  }}
                  onBlur={(e) => {
                    if (e.target.value === '') setCycleTime(30);
                  }}
                  className="w-full px-2 py-1 border rounded text-sm"
                />
              </div>
              <div>
                <label className="text-xs font-medium">Sendoff</label>
                <input
                  type="text"
                  inputMode="numeric"
                  value={sendoff}
                  onFocus={(e) => e.target.select()}
                  onChange={(e) => {
                    const val = e.target.value;
                    if (val === '') {
                      setSendoff('');
                    } else {
                      const num = parseInt(val);
                      if (!isNaN(num) && num > 0) setSendoff(num);
                    }
                  }}
                  onBlur={(e) => {
                    if (e.target.value === '') setSendoff(5);
                  }}
                  className="w-full px-2 py-1 border rounded text-sm"
                />
              </div>
            </div>
            <div className="text-xs text-gray-600">
              Set: {repeats}×{distance} @{cycleTime}s, Sendoff: {sendoff}s
            </div>
          </div>
        )}
      </div>

      <div className="p-2 overflow-x-auto">
        <div className="flex gap-2 min-w-max">
          {Array.from({ length: numLanes }, (_, i) => i + 1).map(laneNum => {
            const hasCustomSettings = !!laneSettings[laneNum];
            
            return (
              <div key={laneNum} className="flex-shrink-0" style={{ width: '32%', minWidth: '120px' }}>
                <div className="mb-2 flex justify-between items-center">
                  <div className="text-xs text-gray-600 font-semibold">
                    Lane {laneNum}
                  </div>
                  {!setRunning && (
                    <button
                      onClick={() => setEditingLane(laneNum)}
                      className={`text-xs px-2 py-0.5 rounded ${
                        hasCustomSettings 
                          ? 'bg-orange-500 text-white' 
                          : 'bg-gray-300 text-gray-700'
                      }`}
                    >
                      {hasCustomSettings ? 'Custom' : 'Edit'}
                    </button>
                  )}
                </div>
                
                <div 
                  onDragOver={handleDragOver}
                  onDrop={(e) => handleDrop(e, laneNum)}
                  className="space-y-2 min-h-96 bg-blue-50 rounded-lg p-2"
                >
                  {lanes[laneNum]?.map(athleteId => {
                    const athlete = athletes.find(a => a.id === athleteId);
                    return athlete ? <AthleteCard key={athleteId} athlete={athlete} laneNum={laneNum} /> : null;
                  })}
                  {(!lanes[laneNum] || lanes[laneNum].length === 0) && (
                    <div className="text-center py-8 text-gray-400 text-xs">
                      Drop athletes here
                    </div>
                  )}
                </div>
              </div>
            );
          })}
        </div>
      </div>

      {showRoster && (
        <div className="fixed inset-0 bg-white z-50 flex flex-col">
          <div className="p-4 border-b flex justify-between items-center">
            <h2 className="text-xl font-bold">Roster</h2>
            <button onClick={() => setShowRoster(false)} className="p-2">
              <X size={24} />
            </button>
          </div>

          <div className="flex gap-2 p-3 border-b overflow-x-auto">
            <button onClick={addAthlete} className="px-3 py-1 bg-blue-600 text-white rounded text-sm whitespace-nowrap">
              <Plus size={14} className="inline" /> Add
            </button>
            <button onClick={distributeAthletes} className="px-3 py-1 bg-green-600 text-white rounded text-sm whitespace-nowrap">
              <RefreshCw size={14} className="inline" /> Group by Speed
            </button>
            <button onClick={distributeAthletesRoundRobin} className="px-3 py-1 bg-teal-600 text-white rounded text-sm whitespace-nowrap">
              <RefreshCw size={14} className="inline" /> Mix Speeds
            </button>
            <button onClick={exportData} className="px-3 py-1 bg-purple-600 text-white rounded text-sm whitespace-nowrap">
              <Download size={14} className="inline" /> Export
            </button>
            <button onClick={importFromClipboard} className="px-3 py-1 bg-purple-600 text-white rounded text-sm whitespace-nowrap">
              <Upload size={14} className="inline" /> Import
            </button>
          </div>

          <div className="flex-1 overflow-y-scroll p-3 space-y-3">
            {athletes.map(athlete => (
              <div key={athlete.id} className={`rounded-lg p-3 border ${athlete.active === false ? 'bg-gray-200 opacity-60' : 'bg-gray-50'}`}>
                {editingAthlete === athlete.id ? (
                  <div className="space-y-2">
                    <input type="text" value={athlete.name} onChange={(e) => updateAthlete(athlete.id, 'name', e.target.value)} className="w-full px-2 py-1 border rounded text-sm" placeholder="Name" />
                    <div>
                      <label className="text-xs font-medium text-gray-600">SwimCloud URL</label>
                      <div className="flex gap-1">
                        <input type="text" value={athlete.swimCloudUrl || ''} onChange={(e) => updateAthlete(athlete.id, 'swimCloudUrl', e.target.value)} className="flex-1 px-2 py-1 border rounded text-sm" placeholder="https://www.swimcloud.com/swimmer/..." />
                        {athlete.swimCloudUrl && <a href={athlete.swimCloudUrl} target="_blank" rel="noopener noreferrer" className="p-1 bg-blue-500 text-white rounded"><ExternalLink size={16} /></a>}
                      </div>
                    </div>
                    <button onClick={() => setShowBatchImport({ ...showBatchImport, [athlete.id]: true })} className="w-full px-3 py-1 bg-green-600 text-white rounded text-sm">Batch Import Times</button>
                    <button onClick={() => setShowAllTimes(athlete.id)} className="w-full px-3 py-1 bg-purple-600 text-white rounded text-sm">View All Times</button>
                    <button onClick={() => setEditingAthlete(null)} className="w-full px-3 py-1 bg-blue-600 text-white rounded text-sm">Done</button>
                  </div>
                ) : (
                  <div className="flex justify-between items-center">
                    <div className="flex-1">
                      <div className="flex items-center gap-2">
                        <div className="font-semibold text-sm">{athlete.name}</div>
                        {athlete.active === false && <span className="text-xs text-gray-500 bg-gray-300 px-2 py-0.5 rounded">Inactive</span>}
                      </div>
                      {getDisplayTime(athlete) && <div className="text-xs text-gray-600">100 Free: {getDisplayTime(athlete)}</div>}
                    </div>
                    <div className="flex gap-2 items-center">
                      <label className="relative inline-flex items-center cursor-pointer">
                        <input type="checkbox" checked={athlete.active !== false} onChange={(e) => { updateAthlete(athlete.id, 'active', e.target.checked); if (!e.target.checked) { const newLanes = { ...lanes }; Object.keys(newLanes).forEach(lane => { newLanes[lane] = newLanes[lane].filter(id => id !== athlete.id); }); setLanes(newLanes); }}} className="sr-only peer" />
                        <div className="w-11 h-6 bg-gray-300 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-green-600"></div>
                      </label>
                      <button onClick={() => setEditingAthlete(athlete.id)} className="p-1 text-blue-600 hover:bg-blue-100 rounded"><Settings size={16} /></button>
                      <button onClick={() => deleteAthlete(athlete.id)} className="p-1 text-red-600 hover:bg-red-100 rounded"><Trash2 size={16} /></button>
                    </div>
                  </div>
                )}
              </div>
            ))}
            {athletes.length === 0 && <div className="text-center py-8 text-gray-500 text-sm">No athletes yet. Click "Add" to create one!</div>}
          </div>
        </div>
      )}

      {showLaneConfig && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
          <div className="bg-white rounded-xl shadow-2xl max-w-sm w-full">
            <div className="p-4 border-b flex justify-between items-center">
              <h2 className="text-lg font-bold">Lane Configuration</h2>
              <button onClick={() => setShowLaneConfig(false)} className="p-2"><X size={20} /></button>
            </div>
            <div className="p-4">
              <label className="block text-sm font-medium text-gray-700 mb-2">Number of Lanes (1-5)</label>
              <div className="flex gap-2">
                {[1, 2, 3, 4, 5].map(num => (
                  <button key={num} onClick={() => setNumLanes(num)} className={`flex-1 px-4 py-3 rounded-lg font-bold text-lg transition-colors ${numLanes === num ? 'bg-blue-600 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}>{num}</button>
                ))}
              </div>
              <p className="mt-3 text-xs text-gray-600">Current: {numLanes} lane{numLanes !== 1 ? 's' : ''}</p>
              <button onClick={() => setShowLaneConfig(false)} className="w-full mt-4 px-4 py-2 bg-blue-600 text-white rounded font-medium">Done</button>
            </div>
          </div>
        </div>
      )}

      {editingLane && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
          <div className="bg-white rounded-xl shadow-2xl max-w-sm w-full">
            <div className="p-4 border-b flex justify-between items-center">
              <h2 className="text-lg font-bold">Lane {editingLane} Settings</h2>
              <button onClick={() => setEditingLane(null)} className="p-2"><X size={20} /></button>
            </div>
            <div className="p-4 space-y-3">
              {laneSettings[editingLane] ? (
                <>
                  <div>
                    <label className="text-sm font-medium">Reps</label>
                    <input type="text" inputMode="numeric" value={getLaneConfig(editingLane).repeats} onFocus={(e) => e.target.select()} onChange={(e) => { const val = e.target.value; if (val === '') { updateLaneSettings(editingLane, { repeats: '' }); } else { const num = parseInt(val); if (!isNaN(num) && num > 0) updateLaneSettings(editingLane, { repeats: num }); }}} onBlur={(e) => { if (e.target.value === '') updateLaneSettings(editingLane, { repeats: repeats }); }} className="w-full px-3 py-2 border rounded mt-1" />
                  </div>
                  <div>
                    <label className="text-sm font-medium">Cycle Time (s)</label>
                    <input type="text" inputMode="numeric" value={getLaneConfig(editingLane).cycleTime} onFocus={(e) => e.target.select()} onChange={(e) => { const val = e.target.value; if (val === '') { updateLaneSettings(editingLane, { cycleTime: '' }); } else { const num = parseInt(val); if (!isNaN(num) && num > 0) updateLaneSettings(editingLane, { cycleTime: num }); }}} onBlur={(e) => { if (e.target.value === '') updateLaneSettings(editingLane, { cycleTime: cycleTime }); }} className="w-full px-3 py-2 border rounded mt-1" />
                  </div>
                  <div>
                    <label className="text-sm font-medium">Sendoff (s)</label>
                    <input type="text" inputMode="numeric" value={getLaneConfig(editingLane).sendoff} onFocus={(e) => e.target.select()} onChange={(e) => { const val = e.target.value; if (val === '') { updateLaneSettings(editingLane, { sendoff: '' }); } else { const num = parseInt(val); if (!isNaN(num) && num > 0) updateLaneSettings(editingLane, { sendoff: num }); }}} onBlur={(e) => { if (e.target.value === '') updateLaneSettings(editingLane, { sendoff: sendoff }); }} className="w-full px-3 py-2 border rounded mt-1" />
                  </div>
                  <button onClick={() => { resetLaneSettings(editingLane); setEditingLane(null); }} className="w-full px-4 py-2 bg-orange-500 text-white rounded font-medium">Reset to Default</button>
                </>
              ) : (
                <div className="text-center py-4">
                  <p className="text-sm text-gray-600 mb-4">Currently using default settings:<br/>{repeats} reps × {distance}m @ {cycleTime}s, {sendoff}s sendoff</p>
                  <button onClick={() => updateLaneSettings(editingLane, { repeats, cycleTime, sendoff })} className="w-full px-4 py-2 bg-blue-600 text-white rounded font-medium">Create Custom Settings</button>
                </div>
              )}
              <button onClick={() => setEditingLane(null)} className="w-full mt-3 px-4 py-2 bg-gray-600 text-white rounded font-medium">Done</button>
            </div>
          </div>
        </div>
      )}

      {showSaveSetModal && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
          <div className="bg-white rounded-xl shadow-2xl max-w-sm w-full">
            <div className="p-4">
              <h2 className="text-xl font-bold mb-3">Save Training Data?</h2>
              <p className="text-sm text-gray-600 mb-4">Save splits from this training set?</p>
              <div className="flex gap-2">
                <button onClick={saveSetData} className="flex-1 px-4 py-2 bg-green-600 text-white rounded font-medium">Save</button>
                <button onClick={discardSetData} className="flex-1 px-4 py-2 bg-red-600 text-white rounded font-medium">Discard</button>
              </div>
            </div>
          </div>
        </div>
      )}

      {showBestTimeModal && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
          <div className="bg-white rounded-xl shadow-2xl max-w-sm w-full">
            <div className="p-4">
              <h2 className="text-xl font-bold mb-3">New Best Times!</h2>
              <div className="space-y-3 mb-4">
                {showBestTimeModal.map((bt, idx) => (
                  <div key={idx} className="bg-green-50 p-3 rounded border border-green-200">
                    <div className="font-semibold text-sm">{bt.athleteName}</div>
                    <div className="text-xs text-gray-600">100 Free: {bt.oldTime ? <><span className="line-through">{bt.oldTime}</span> → </> : 'NEW! '}<span className="text-green-600 font-bold ml-1">{formatSeconds(bt.newTime)}</span></div>
                    <button onClick={() => { approveBestTime(bt.athleteId, bt.newTime); setShowBestTimeModal(prev => prev.filter((_, i) => i !== idx)); if (showBestTimeModal.length === 1) resetSet(); }} className="mt-2 px-3 py-1 bg-green-600 text-white rounded text-sm">Approve</button>
                    <button onClick={() => { setShowBestTimeModal(prev => prev.filter((_, i) => i !== idx)); if (showBestTimeModal.length === 1) resetSet(); }} className="mt-2 ml-2 px-3 py-1 bg-gray-400 text-white rounded text-sm">Reject</button>
                  </div>
                ))}
              </div>
              <button onClick={resetSet} className="w-full px-4 py-2 bg-gray-600 text-white rounded font-medium">Skip All</button>
            </div>
          </div>
        </div>
      )}

      {showBatchImport[editingAthlete] && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
          <div className="bg-white rounded-xl shadow-2xl max-w-md w-full">
            <div className="p-4 border-b flex justify-between items-center">
              <h2 className="text-lg font-bold">Batch Import Times</h2>
              <button onClick={() => setShowBatchImport({ ...showBatchImport, [editingAthlete]: false })} className="p-2"><X size={20} /></button>
            </div>
            <div className="p-4">
              <p className="text-xs text-gray-600 mb-2">Paste times from SwimCloud. Examples:<br/>50 Free: 23.45 (SCY)<br/>100 Free 51.20<br/>200 Free: 1:52.30 LCM</p>
              <textarea value={batchImportText[editingAthlete] || ''} onChange={(e) => { const newText = { ...batchImportText }; newText[editingAthlete] = e.target.value; setBatchImportText(newText); }} className="w-full h-48 px-2 py-2 border rounded text-sm font-mono" placeholder="50 Free: 23.45 (SCY)" />
              <div className="flex gap-2 mt-3">
                <button onClick={() => processBatchImport(editingAthlete)} className="flex-1 px-4 py-2 bg-blue-600 text-white rounded font-medium">Import</button>
                <button onClick={() => setShowBatchImport({ ...showBatchImport, [editingAthlete]: false })} className="px-4 py-2 bg-gray-200 text-gray-700 rounded font-medium">Cancel</button>
              </div>
            </div>
          </div>
        </div>
      )}

      {showAllTimes && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
          <div className="bg-white rounded-xl shadow-2xl max-w-2xl w-full max-h-96 overflow-hidden flex flex-col">
            <div className="p-4 border-b flex justify-between items-center flex-shrink-0">
              <h2 className="text-lg font-bold">{athletes.find(a => a.id === showAllTimes)?.name} - All Times</h2>
              <button onClick={() => setShowAllTimes(null)} className="p-2"><X size={20} /></button>
            </div>
            <div className="flex border-b flex-shrink-0">
              {['SCY', 'LCM', 'SCM'].map(course => (
                <button key={course} onClick={() => setCourseView(course)} className={`flex-1 px-4 py-2 font-medium ${courseView === course ? 'bg-blue-600 text-white' : 'bg-gray-100 text-gray-600 hover:bg-gray-200'}`}>{course}</button>
              ))}
            </div>
            <div className="p-4 overflow-y-auto flex-1">
              {(() => {
                const athlete = athletes.find(a => a.id === showAllTimes);
                const hasTimes = EVENTS.some(event => athlete?.times?.[event]?.[courseView]);
                if (!hasTimes) return <div className="text-center py-8 text-gray-500">No {courseView} times recorded yet</div>;
                return (
                  <div className="grid grid-cols-2 gap-3">
                    {EVENTS.map(event => {
                      const time = athlete?.times?.[event]?.[courseView];
                      if (!time) return null;
                      return (
                        <div key={event} className="bg-gray-50 p-3 rounded border">
                          <div className="text-sm font-semibold text-gray-700">{event}</div>
                          <div className="text-lg font-mono font-bold text-blue-600">{time}</div>
                        </div>
                      );
                    })}
                  </div>
                );
              })()}
            </div>
          </div>
        </div>
      )}

      {showManualImport && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
          <div className="bg-white rounded-xl shadow-2xl max-w-md w-full">
            <div className="p-4 border-b flex justify-between items-center">
              <h2 className="text-lg font-bold">Paste Data</h2>
              <button onClick={() => setShowManualImport(false)} className="p-2"><X size={20} /></button>
            </div>
            <div className="p-4">
              <textarea value={manualImportText} onChange={(e) => setManualImportText(e.target.value)} className="w-full h-48 px-2 py-2 border rounded text-sm font-mono" placeholder='{"athletes": [...], "numLanes": 3}' />
              <div className="flex gap-2 mt-3">
                <button onClick={() => processImportData(manualImportText)} className="flex-1 px-4 py-2 bg-blue-600 text-white rounded font-medium">Import</button>
                <button onClick={() => setShowManualImport(false)} className="px-4 py-2 bg-gray-200 text-gray-700 rounded font-medium">Cancel</button>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<SwimCoachApp />);
    </script>
</body>
</html>
